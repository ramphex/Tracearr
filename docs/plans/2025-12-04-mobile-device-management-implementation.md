# Mobile Device Management Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Enable adding multiple mobile devices without invalidating existing sessions, and allow individual device deletion.

**Architecture:** One-time pairing tokens (15 min expiry) replace global token. New `mobile_enabled` setting in settings table. Individual device deletion via `DELETE /mobile/sessions/:id`. Transactional pairing with row-level locking.

**Tech Stack:** Fastify, Drizzle ORM, PostgreSQL, React, TanStack Query, Zod

---

## Task 1: Add `mobileEnabled` Column to Settings Table

**Files:**
- Modify: `apps/server/src/db/schema.ts:397-417`
- Create: `apps/server/src/db/migrations/0007_mobile_enabled.sql` (generated by drizzle-kit)

**Step 1: Add column to schema**

In `apps/server/src/db/schema.ts`, add `mobileEnabled` to the `settings` table (after line 415):

```typescript
// Application settings (single row)
export const settings = pgTable('settings', {
  id: integer('id').primaryKey().default(1),
  allowGuestAccess: boolean('allow_guest_access').notNull().default(false),
  discordWebhookUrl: text('discord_webhook_url'),
  customWebhookUrl: text('custom_webhook_url'),
  notifyOnViolation: boolean('notify_on_violation').notNull().default(true),
  notifyOnSessionStart: boolean('notify_on_session_start').notNull().default(false),
  notifyOnSessionStop: boolean('notify_on_session_stop').notNull().default(false),
  notifyOnServerDown: boolean('notify_on_server_down').notNull().default(true),
  // Poller settings
  pollerEnabled: boolean('poller_enabled').notNull().default(true),
  pollerIntervalMs: integer('poller_interval_ms').notNull().default(15000),
  // Tautulli integration
  tautulliUrl: text('tautulli_url'),
  tautulliApiKey: text('tautulli_api_key'), // Encrypted
  // Network/access settings for self-hosted deployments
  externalUrl: text('external_url'),
  basePath: varchar('base_path', { length: 100 }).notNull().default(''),
  trustProxy: boolean('trust_proxy').notNull().default(false),
  // Mobile access
  mobileEnabled: boolean('mobile_enabled').notNull().default(false),
  updatedAt: timestamp('updated_at', { withTimezone: true }).notNull().defaultNow(),
});
```

**Step 2: Generate migration**

Run: `cd apps/server && pnpm db:generate`

Expected: New migration file created in `apps/server/src/db/migrations/`

**Step 3: Run migration**

Run: `cd apps/server && pnpm db:migrate`

Expected: Migration applied successfully

**Step 4: Commit**

```bash
git add apps/server/src/db/schema.ts apps/server/src/db/migrations/
git commit -m "feat(db): add mobileEnabled column to settings table"
```

---

## Task 2: Update `mobileTokens` Schema for One-Time Tokens

**Files:**
- Modify: `apps/server/src/db/schema.ts:275-282`

**Step 1: Update mobileTokens table schema**

Replace the existing `mobileTokens` definition:

```typescript
// Mobile pairing tokens (one-time use, expire after 15 minutes)
export const mobileTokens = pgTable('mobile_tokens', {
  id: uuid('id').primaryKey().defaultRandom(),
  tokenHash: varchar('token_hash', { length: 64 }).notNull().unique(), // SHA-256 of trr_mob_xxx token
  expiresAt: timestamp('expires_at', { withTimezone: true }).notNull(),
  createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),
  createdBy: uuid('created_by').references(() => users.id, { onDelete: 'cascade' }),
  usedAt: timestamp('used_at', { withTimezone: true }), // Set when token is used, null = unused
});
```

**Step 2: Generate migration**

Run: `cd apps/server && pnpm db:generate`

Expected: Migration file created

**Step 3: Run migration**

Run: `cd apps/server && pnpm db:migrate`

Expected: Migration applied (may need to handle existing data - old tokens will be cleared)

**Step 4: Commit**

```bash
git add apps/server/src/db/schema.ts apps/server/src/db/migrations/
git commit -m "feat(db): update mobileTokens for one-time pairing tokens"
```

---

## Task 3: Update Shared Types

**Files:**
- Modify: `packages/shared/src/types.ts:464-489`

**Step 1: Update MobileToken type**

Replace the existing `MobileToken` interface:

```typescript
// Mobile pairing token (one-time use)
export interface MobileToken {
  id: string;
  expiresAt: Date;
  createdAt: Date;
  usedAt: Date | null;
}

// Mobile pairing token response (when generating new token)
export interface MobilePairTokenResponse {
  token: string;
  expiresAt: Date;
}
```

**Step 2: Update MobileConfig type**

Replace the existing `MobileConfig` interface:

```typescript
// Mobile config returned to web dashboard
export interface MobileConfig {
  isEnabled: boolean;
  sessions: MobileSession[];
  serverName: string;
  pendingTokens: number; // Count of unexpired, unused tokens
  maxDevices: number; // Maximum allowed devices (5)
}
```

**Step 3: Add Settings type update**

In the `Settings` interface (around line 350), add:

```typescript
export interface Settings {
  // ... existing fields ...
  // Mobile access
  mobileEnabled: boolean;
}
```

**Step 4: Commit**

```bash
git add packages/shared/src/types.ts
git commit -m "feat(shared): update types for one-time mobile pairing tokens"
```

---

## Task 4: Update `GET /mobile` Endpoint

**Files:**
- Modify: `apps/server/src/routes/mobile.ts:87-122`

**Step 1: Update the GET endpoint**

Replace the existing `GET /` handler:

```typescript
/**
 * GET /mobile - Get mobile config
 */
app.get('/', { preHandler: [app.authenticate] }, async (request, reply) => {
  const authUser = request.user;

  if (authUser.role !== 'owner') {
    return reply.forbidden('Only server owners can access mobile settings');
  }

  // Get mobile enabled status from settings
  const settingsRow = await db.select({ mobileEnabled: settings.mobileEnabled }).from(settings).limit(1);
  const isEnabled = settingsRow[0]?.mobileEnabled ?? false;

  // Get mobile sessions
  const sessionsRows = await db.select().from(mobileSessions);

  // Count pending tokens (unexpired and unused)
  const pendingTokensResult = await db
    .select({ count: sql<number>`count(*)::int` })
    .from(mobileTokens)
    .where(
      and(
        gt(mobileTokens.expiresAt, new Date()),
        isNull(mobileTokens.usedAt)
      )
    );
  const pendingTokens = pendingTokensResult[0]?.count ?? 0;

  // Get server name
  const serverRow = await db.select({ name: servers.name }).from(servers).limit(1);
  const serverName = serverRow[0]?.name || 'Tracearr';

  const sessions: MobileSession[] = sessionsRows.map((s) => ({
    id: s.id,
    deviceName: s.deviceName,
    deviceId: s.deviceId,
    platform: s.platform,
    expoPushToken: s.expoPushToken,
    lastSeenAt: s.lastSeenAt,
    createdAt: s.createdAt,
  }));

  const config: MobileConfig = {
    isEnabled,
    sessions,
    serverName,
    pendingTokens,
    maxDevices: MAX_PAIRED_DEVICES,
  };

  return config;
});
```

**Step 2: Add imports and constants at top of file**

Add near the top of the file (after existing imports):

```typescript
import { and, gt, isNull, sql } from 'drizzle-orm';
import { settings } from '../db/schema.js';

// Limits
const MAX_PAIRED_DEVICES = 5;
const MAX_PENDING_TOKENS = 3;
const TOKEN_EXPIRY_MINUTES = 15;
const TOKEN_GEN_RATE_LIMIT = 3; // Max tokens per 5 minutes
const TOKEN_GEN_RATE_WINDOW = 5 * 60; // 5 minutes in seconds
```

**Step 3: Commit**

```bash
git add apps/server/src/routes/mobile.ts
git commit -m "feat(api): update GET /mobile to use settings.mobileEnabled"
```

---

## Task 5: Update `POST /mobile/enable` Endpoint

**Files:**
- Modify: `apps/server/src/routes/mobile.ts:127-192`

**Step 1: Replace the enable endpoint**

Replace the existing `POST /enable` handler:

```typescript
/**
 * POST /mobile/enable - Enable mobile access (no token generated)
 */
app.post('/enable', { preHandler: [app.authenticate] }, async (request, reply) => {
  const authUser = request.user;

  if (authUser.role !== 'owner') {
    return reply.forbidden('Only server owners can enable mobile access');
  }

  // Update settings to enable mobile
  await db
    .update(settings)
    .set({ mobileEnabled: true, updatedAt: new Date() })
    .where(eq(settings.id, 1));

  // Get current state for response
  const sessionsRows = await db.select().from(mobileSessions);
  const serverRow = await db.select({ name: servers.name }).from(servers).limit(1);
  const serverName = serverRow[0]?.name || 'Tracearr';

  const sessions: MobileSession[] = sessionsRows.map((s) => ({
    id: s.id,
    deviceName: s.deviceName,
    deviceId: s.deviceId,
    platform: s.platform,
    expoPushToken: s.expoPushToken,
    lastSeenAt: s.lastSeenAt,
    createdAt: s.createdAt,
  }));

  const config: MobileConfig = {
    isEnabled: true,
    sessions,
    serverName,
    pendingTokens: 0,
    maxDevices: MAX_PAIRED_DEVICES,
  };

  app.log.info({ userId: authUser.userId }, 'Mobile access enabled');

  return config;
});
```

**Step 2: Commit**

```bash
git add apps/server/src/routes/mobile.ts
git commit -m "feat(api): update POST /mobile/enable to only set flag"
```

---

## Task 6: Implement `POST /mobile/pair-token` Endpoint

**Files:**
- Modify: `apps/server/src/routes/mobile.ts` (add new endpoint after enable)

**Step 1: Add the new endpoint**

Add after the `/enable` endpoint:

```typescript
/**
 * POST /mobile/pair-token - Generate a one-time pairing token
 *
 * Rate limited: 3 tokens per 5 minutes per user
 * Max pending tokens: 3
 * Max paired devices: 5
 */
app.post('/pair-token', { preHandler: [app.authenticate] }, async (request, reply) => {
  const authUser = request.user;

  if (authUser.role !== 'owner') {
    return reply.forbidden('Only server owners can generate pairing tokens');
  }

  // Check if mobile is enabled
  const settingsRow = await db.select({ mobileEnabled: settings.mobileEnabled }).from(settings).limit(1);
  if (!settingsRow[0]?.mobileEnabled) {
    return reply.badRequest('Mobile access is not enabled');
  }

  // Rate limiting: max 3 tokens per 5 minutes
  const rateLimitKey = `mobile_token_gen:${authUser.userId}`;
  const currentCount = await app.redis.incr(rateLimitKey);
  if (currentCount === 1) {
    await app.redis.expire(rateLimitKey, TOKEN_GEN_RATE_WINDOW);
  }
  if (currentCount > TOKEN_GEN_RATE_LIMIT) {
    const ttl = await app.redis.ttl(rateLimitKey);
    reply.header('Retry-After', String(ttl > 0 ? ttl : TOKEN_GEN_RATE_WINDOW));
    return reply.tooManyRequests('Too many token generation attempts. Please try again later.');
  }

  // Check max pending tokens
  const pendingTokensResult = await db
    .select({ count: sql<number>`count(*)::int` })
    .from(mobileTokens)
    .where(
      and(
        gt(mobileTokens.expiresAt, new Date()),
        isNull(mobileTokens.usedAt)
      )
    );
  const pendingCount = pendingTokensResult[0]?.count ?? 0;

  if (pendingCount >= MAX_PENDING_TOKENS) {
    return reply.badRequest(
      `Maximum of ${MAX_PENDING_TOKENS} pending tokens allowed. Wait for expiry or use an existing token.`
    );
  }

  // Check max paired devices
  const sessionsCount = await db
    .select({ count: sql<number>`count(*)::int` })
    .from(mobileSessions);
  const deviceCount = sessionsCount[0]?.count ?? 0;

  if (deviceCount >= MAX_PAIRED_DEVICES) {
    return reply.badRequest(
      `Maximum of ${MAX_PAIRED_DEVICES} devices allowed. Remove a device first.`
    );
  }

  // Generate token
  const plainToken = generateMobileToken();
  const tokenHash = hashToken(plainToken);
  const expiresAt = new Date(Date.now() + TOKEN_EXPIRY_MINUTES * 60 * 1000);

  await db.insert(mobileTokens).values({
    tokenHash,
    expiresAt,
    createdBy: authUser.userId,
  });

  app.log.info({ userId: authUser.userId }, 'Mobile pairing token generated');

  const response: MobilePairTokenResponse = {
    token: plainToken,
    expiresAt,
  };

  return response;
});
```

**Step 2: Add type import**

At the top of the file, update imports:

```typescript
import type { MobileConfig, MobileSession, MobilePairResponse, MobilePairTokenResponse } from '@tracearr/shared';
```

**Step 3: Commit**

```bash
git add apps/server/src/routes/mobile.ts
git commit -m "feat(api): add POST /mobile/pair-token endpoint"
```

---

## Task 7: Update `POST /mobile/disable` Endpoint

**Files:**
- Modify: `apps/server/src/routes/mobile.ts:197-217`

**Step 1: Replace the disable endpoint**

```typescript
/**
 * POST /mobile/disable - Disable mobile access
 */
app.post('/disable', { preHandler: [app.authenticate] }, async (request, reply) => {
  const authUser = request.user;

  if (authUser.role !== 'owner') {
    return reply.forbidden('Only server owners can disable mobile access');
  }

  // Disable in settings
  await db
    .update(settings)
    .set({ mobileEnabled: false, updatedAt: new Date() })
    .where(eq(settings.id, 1));

  // Revoke all mobile sessions (delete from DB and Redis)
  const sessionsRows = await db.select().from(mobileSessions);
  for (const session of sessionsRows) {
    await app.redis.del(`${MOBILE_REFRESH_PREFIX}${session.refreshTokenHash}`);
  }
  await db.delete(mobileSessions);

  // Delete all pending tokens
  await db.delete(mobileTokens);

  app.log.info({ userId: authUser.userId }, 'Mobile access disabled');

  return { success: true };
});
```

**Step 2: Commit**

```bash
git add apps/server/src/routes/mobile.ts
git commit -m "feat(api): update POST /mobile/disable to use settings flag"
```

---

## Task 8: Remove `POST /mobile/rotate` Endpoint

**Files:**
- Modify: `apps/server/src/routes/mobile.ts:219-268`

**Step 1: Delete the rotate endpoint**

Remove the entire `POST /rotate` handler (lines 219-268).

**Step 2: Update file header comment**

Update the comment at the top of the file:

```typescript
/**
 * Mobile routes - Mobile app pairing, authentication, and session management
 *
 * Settings endpoints (owner only):
 * - GET /mobile - Get mobile config (enabled status, sessions)
 * - POST /mobile/enable - Enable mobile access
 * - POST /mobile/disable - Disable mobile access
 * - POST /mobile/pair-token - Generate one-time pairing token
 * - DELETE /mobile/sessions - Revoke all mobile sessions
 * - DELETE /mobile/sessions/:id - Revoke single mobile session
 *
 * Auth endpoints (mobile app):
 * - POST /mobile/pair - Exchange pairing token for JWT
 * - POST /mobile/refresh - Refresh mobile JWT
 * - POST /mobile/push-token - Register push token
 */
```

**Step 3: Commit**

```bash
git add apps/server/src/routes/mobile.ts
git commit -m "feat(api): remove POST /mobile/rotate endpoint"
```

---

## Task 9: Implement `DELETE /mobile/sessions/:id` Endpoint

**Files:**
- Modify: `apps/server/src/routes/mobile.ts` (add after DELETE /sessions)

**Step 1: Add the new endpoint**

Add after the `DELETE /sessions` endpoint:

```typescript
/**
 * DELETE /mobile/sessions/:id - Revoke a single mobile session
 */
app.delete('/sessions/:id', { preHandler: [app.authenticate] }, async (request, reply) => {
  const authUser = request.user;

  if (authUser.role !== 'owner') {
    return reply.forbidden('Only server owners can revoke mobile sessions');
  }

  const { id } = request.params as { id: string };

  // Validate UUID format
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  if (!uuidRegex.test(id)) {
    return reply.badRequest('Invalid session ID format');
  }

  // Find the session
  const sessionRow = await db
    .select()
    .from(mobileSessions)
    .where(eq(mobileSessions.id, id))
    .limit(1);

  if (sessionRow.length === 0) {
    return reply.notFound('Mobile session not found');
  }

  const session = sessionRow[0]!;

  // Delete refresh token from Redis
  await app.redis.del(`${MOBILE_REFRESH_PREFIX}${session.refreshTokenHash}`);

  // Delete session from DB (notification_preferences cascade-deleted via FK)
  await db.delete(mobileSessions).where(eq(mobileSessions.id, id));

  app.log.info(
    { userId: authUser.userId, sessionId: id, deviceName: session.deviceName },
    'Mobile session revoked'
  );

  return { success: true };
});
```

**Step 2: Commit**

```bash
git add apps/server/src/routes/mobile.ts
git commit -m "feat(api): add DELETE /mobile/sessions/:id endpoint"
```

---

## Task 10: Update `POST /mobile/pair` to Use Transactional Token Consumption

**Files:**
- Modify: `apps/server/src/routes/mobile.ts:301-438`

**Step 1: Update the pair endpoint**

Replace the existing `POST /pair` handler with transactional logic:

```typescript
/**
 * POST /mobile/pair - Exchange pairing token for JWT
 *
 * Rate limited: 5 attempts per IP per 15 minutes to prevent brute force
 */
app.post('/pair', async (request, reply) => {
  // Rate limiting check
  const clientIp = request.ip;
  const rateLimitKey = REDIS_KEYS.RATE_LIMIT_MOBILE_PAIR(clientIp);
  const currentCount = await app.redis.incr(rateLimitKey);

  if (currentCount === 1) {
    await app.redis.expire(rateLimitKey, CACHE_TTL.RATE_LIMIT);
  }

  if (currentCount > MOBILE_PAIR_MAX_ATTEMPTS) {
    const ttl = await app.redis.ttl(rateLimitKey);
    app.log.warn({ ip: clientIp, count: currentCount }, 'Mobile pair rate limit exceeded');
    reply.header('Retry-After', String(ttl > 0 ? ttl : CACHE_TTL.RATE_LIMIT));
    return reply.tooManyRequests('Too many pairing attempts. Please try again later.');
  }

  const body = mobilePairSchema.safeParse(request.body);
  if (!body.success) {
    return reply.badRequest('Invalid pairing request');
  }

  const { token, deviceName, deviceId, platform, deviceSecret } = body.data;

  // Verify token starts with correct prefix
  if (!token.startsWith(MOBILE_TOKEN_PREFIX)) {
    return reply.unauthorized('Invalid mobile token');
  }

  const tokenHash = hashToken(token);

  // Check max devices before attempting pair
  const sessionsCount = await db
    .select({ count: sql<number>`count(*)::int` })
    .from(mobileSessions);
  const deviceCount = sessionsCount[0]?.count ?? 0;

  // Check if this device is already paired (would be an update, not new)
  const existingSession = await db
    .select()
    .from(mobileSessions)
    .where(eq(mobileSessions.deviceId, deviceId))
    .limit(1);

  if (existingSession.length === 0 && deviceCount >= MAX_PAIRED_DEVICES) {
    return reply.badRequest(
      `Maximum of ${MAX_PAIRED_DEVICES} devices allowed. Remove a device first.`
    );
  }

  // Use transaction with row-level locking to prevent race conditions
  let result: {
    accessToken: string;
    refreshToken: string;
    owner: { id: string; username: string };
    serverName: string;
    serverIds: string[];
  };

  try {
    result = await db.transaction(async (tx) => {
      // Lock and validate token
      const tokenRows = await tx
        .select()
        .from(mobileTokens)
        .where(eq(mobileTokens.tokenHash, tokenHash))
        .for('update')
        .limit(1);

      if (tokenRows.length === 0) {
        throw new Error('INVALID_TOKEN');
      }

      const tokenRow = tokenRows[0]!;

      if (tokenRow.usedAt) {
        throw new Error('TOKEN_ALREADY_USED');
      }

      if (tokenRow.expiresAt < new Date()) {
        throw new Error('TOKEN_EXPIRED');
      }

      // Get the owner user
      const ownerRow = await tx
        .select()
        .from(users)
        .where(eq(users.role, 'owner'))
        .limit(1);

      if (ownerRow.length === 0) {
        throw new Error('NO_OWNER');
      }

      const owner = ownerRow[0]!;

      // Get all server IDs for the JWT
      const allServers = await tx.select({ id: servers.id }).from(servers);
      const serverIds = allServers.map((s) => s.id);

      // Get server name
      const serverRow = await tx.select({ name: servers.name }).from(servers).limit(1);
      const serverName = serverRow[0]?.name || 'Tracearr';

      // Generate refresh token
      const newRefreshToken = generateRefreshToken();
      const refreshTokenHash = hashToken(newRefreshToken);

      // Create or update session
      if (existingSession.length > 0) {
        // Update existing session
        const oldHash = existingSession[0]!.refreshTokenHash;
        await app.redis.del(`${MOBILE_REFRESH_PREFIX}${oldHash}`);

        await tx
          .update(mobileSessions)
          .set({
            refreshTokenHash,
            deviceName,
            platform,
            deviceSecret: deviceSecret ?? null,
            lastSeenAt: new Date(),
          })
          .where(eq(mobileSessions.id, existingSession[0]!.id));
      } else {
        // Create new session
        await tx.insert(mobileSessions).values({
          refreshTokenHash,
          deviceName,
          deviceId,
          platform,
          deviceSecret: deviceSecret ?? null,
        });
      }

      // Mark token as used (not deleted - for audit trail)
      await tx
        .update(mobileTokens)
        .set({ usedAt: new Date() })
        .where(eq(mobileTokens.id, tokenRow.id));

      // Generate access token
      const accessToken = app.jwt.sign(
        {
          userId: owner.id,
          username: owner.username,
          role: 'owner',
          serverIds,
          mobile: true,
          deviceId,
        },
        { expiresIn: MOBILE_ACCESS_EXPIRY }
      );

      return {
        accessToken,
        refreshToken: newRefreshToken,
        owner: { id: owner.id, username: owner.username },
        serverName,
        serverIds,
      };
    });
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Unknown error';

    if (message === 'INVALID_TOKEN') {
      return reply.unauthorized('Invalid mobile token');
    }
    if (message === 'TOKEN_ALREADY_USED') {
      return reply.unauthorized('This pairing token has already been used');
    }
    if (message === 'TOKEN_EXPIRED') {
      return reply.unauthorized('This pairing token has expired');
    }
    if (message === 'NO_OWNER') {
      return reply.internalServerError('No owner account found');
    }

    app.log.error({ err }, 'Mobile pairing transaction failed');
    return reply.internalServerError('Pairing failed. Please try again.');
  }

  // Store refresh token in Redis (outside transaction)
  await app.redis.setex(
    `${MOBILE_REFRESH_PREFIX}${hashToken(result.refreshToken)}`,
    MOBILE_REFRESH_TTL,
    JSON.stringify({ userId: result.owner.id, deviceId })
  );

  app.log.info({ deviceName, platform, deviceId }, 'Mobile device paired');

  const response: MobilePairResponse = {
    accessToken: result.accessToken,
    refreshToken: result.refreshToken,
    server: {
      name: result.serverName,
      url: '',
    },
    user: {
      userId: result.owner.id,
      username: result.owner.username,
      role: 'owner',
    },
  };

  return response;
});
```

**Step 2: Commit**

```bash
git add apps/server/src/routes/mobile.ts
git commit -m "feat(api): update POST /mobile/pair with transactional token consumption"
```

---

## Task 11: Update Web API Client

**Files:**
- Modify: `apps/web/src/lib/api.ts:522-530`

**Step 1: Update mobile API methods**

Replace the mobile section:

```typescript
// Mobile access
mobile = {
  get: () => this.request<MobileConfig>('/mobile'),
  enable: () => this.request<MobileConfig>('/mobile/enable', { method: 'POST', body: '{}' }),
  disable: () => this.request<{ success: boolean }>('/mobile/disable', { method: 'POST', body: '{}' }),
  generatePairToken: () =>
    this.request<{ token: string; expiresAt: string }>('/mobile/pair-token', { method: 'POST', body: '{}' }),
  revokeSession: (id: string) =>
    this.request<{ success: boolean }>(`/mobile/sessions/${id}`, { method: 'DELETE' }),
  revokeSessions: () =>
    this.request<{ success: boolean; revokedCount: number }>('/mobile/sessions', { method: 'DELETE' }),
};
```

**Step 2: Update imports if needed**

Ensure `MobileConfig` is imported (should already be there).

**Step 3: Commit**

```bash
git add apps/web/src/lib/api.ts
git commit -m "feat(web): update mobile API client methods"
```

---

## Task 12: Update React Query Hooks

**Files:**
- Modify: `apps/web/src/hooks/queries/useMobile.ts`

**Step 1: Replace the entire file**

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import type { MobileConfig } from '@tracearr/shared';
import { api } from '@/lib/api';
import { useToast } from '@/hooks/use-toast';

export function useMobileConfig() {
  return useQuery({
    queryKey: ['mobile', 'config'],
    queryFn: api.mobile.get,
    staleTime: 1000 * 60 * 5, // 5 minutes
  });
}

export function useEnableMobile() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: api.mobile.enable,
    onSuccess: (data) => {
      queryClient.setQueryData<MobileConfig>(['mobile', 'config'], data);
      toast({
        title: 'Mobile Access Enabled',
        description: 'Click "Add Device" to generate a pairing QR code.',
      });
    },
    onError: (err) => {
      toast({
        title: 'Failed to Enable Mobile Access',
        description: err.message,
        variant: 'destructive',
      });
    },
  });
}

export function useDisableMobile() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: api.mobile.disable,
    onSuccess: () => {
      queryClient.setQueryData<MobileConfig>(['mobile', 'config'], (old) => {
        if (!old) return old;
        return { ...old, isEnabled: false, sessions: [], pendingTokens: 0 };
      });
      toast({
        title: 'Mobile Access Disabled',
        description: 'All mobile sessions have been revoked.',
      });
    },
    onError: (err) => {
      toast({
        title: 'Failed to Disable Mobile Access',
        description: err.message,
        variant: 'destructive',
      });
    },
  });
}

export function useGeneratePairToken() {
  const { toast } = useToast();

  return useMutation({
    mutationFn: api.mobile.generatePairToken,
    onError: (err) => {
      toast({
        title: 'Failed to Generate Pairing Token',
        description: err.message,
        variant: 'destructive',
      });
    },
  });
}

export function useRevokeSession() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: (sessionId: string) => api.mobile.revokeSession(sessionId),
    onSuccess: (_, sessionId) => {
      queryClient.setQueryData<MobileConfig>(['mobile', 'config'], (old) => {
        if (!old) return old;
        return {
          ...old,
          sessions: old.sessions.filter((s) => s.id !== sessionId),
        };
      });
      toast({
        title: 'Device Removed',
        description: 'The device has been disconnected.',
      });
    },
    onError: (err) => {
      toast({
        title: 'Failed to Remove Device',
        description: err.message,
        variant: 'destructive',
      });
    },
  });
}

export function useRevokeMobileSessions() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: api.mobile.revokeSessions,
    onSuccess: (data) => {
      queryClient.setQueryData<MobileConfig>(['mobile', 'config'], (old) => {
        if (!old) return old;
        return { ...old, sessions: [] };
      });
      toast({
        title: 'Sessions Revoked',
        description: `${data.revokedCount} mobile session(s) have been revoked.`,
      });
    },
    onError: (err) => {
      toast({
        title: 'Failed to Revoke Sessions',
        description: err.message,
        variant: 'destructive',
      });
    },
  });
}
```

**Step 2: Commit**

```bash
git add apps/web/src/hooks/queries/useMobile.ts
git commit -m "feat(web): update mobile React Query hooks"
```

---

## Task 13: Update MobileSettings UI Component

**Files:**
- Modify: `apps/web/src/pages/Settings.tsx:882-1158`

**Step 1: Replace the MobileSettings function**

This is a larger change. Replace the entire `MobileSettings` function:

```typescript
function MobileSettings() {
  const { data: config, isLoading } = useMobileConfig();
  const { data: settings } = useSettings();
  const enableMobile = useEnableMobile();
  const disableMobile = useDisableMobile();
  const generatePairToken = useGeneratePairToken();
  const revokeMobileSessions = useRevokeMobileSessions();

  const [showDisableConfirm, setShowDisableConfirm] = useState(false);
  const [showRevokeConfirm, setShowRevokeConfirm] = useState(false);
  const [showAddDevice, setShowAddDevice] = useState(false);
  const [pairToken, setPairToken] = useState<{ token: string; expiresAt: Date } | null>(null);
  const [copied, setCopied] = useState(false);

  const handleCopyToken = async () => {
    if (!pairToken?.token) return;

    try {
      await navigator.clipboard.writeText(pairToken.token);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      // Clipboard API may not be available (non-HTTPS)
      console.error('Failed to copy:', err);
    }
  };

  const handleAddDevice = async () => {
    const result = await generatePairToken.mutateAsync();
    setPairToken({
      token: result.token,
      expiresAt: new Date(result.expiresAt),
    });
    setShowAddDevice(true);
  };

  const getServerUrl = (): string => {
    if (settings?.externalUrl) {
      return settings.externalUrl;
    }
    let serverUrl = window.location.origin;
    if (import.meta.env.DEV) {
      serverUrl = serverUrl.replace(':5173', ':3000');
    }
    return serverUrl;
  };

  const getQRData = (): string => {
    if (!pairToken?.token) return '';
    const payload: MobileQRPayload = {
      url: getServerUrl(),
      token: pairToken.token,
      name: config?.serverName || 'Tracearr',
    };
    const encoded = btoa(JSON.stringify(payload));
    return `tracearr://pair?data=${encoded}`;
  };

  // Calculate time remaining for token
  const getTimeRemaining = (): string => {
    if (!pairToken?.expiresAt) return '';
    const now = new Date();
    const diff = pairToken.expiresAt.getTime() - now.getTime();
    if (diff <= 0) return 'Expired';
    const minutes = Math.floor(diff / 60000);
    const seconds = Math.floor((diff % 60000) / 1000);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  // Auto-refresh time remaining
  const [timeRemaining, setTimeRemaining] = useState('');
  useEffect(() => {
    if (!pairToken?.expiresAt) return;

    const interval = setInterval(() => {
      const remaining = getTimeRemaining();
      setTimeRemaining(remaining);
      if (remaining === 'Expired') {
        clearInterval(interval);
      }
    }, 1000);

    setTimeRemaining(getTimeRemaining());
    return () => clearInterval(interval);
  }, [pairToken?.expiresAt]);

  if (isLoading) {
    return (
      <Card>
        <CardHeader>
          <Skeleton className="h-6 w-32" />
        </CardHeader>
        <CardContent className="space-y-4">
          <Skeleton className="h-10 w-full" />
          <Skeleton className="h-48 w-48" />
        </CardContent>
      </Card>
    );
  }

  const canAddDevice = (config?.sessions.length ?? 0) < (config?.maxDevices ?? 5);

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Smartphone className="h-5 w-5" />
            Mobile App Access
          </CardTitle>
          <CardDescription>
            Connect the Tracearr mobile app to monitor your servers on the go
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          {!config?.isEnabled ? (
            <div className="flex flex-col items-center justify-center gap-4 rounded-lg border border-dashed p-8">
              <div className="rounded-full bg-muted p-4">
                <Smartphone className="h-8 w-8 text-muted-foreground" />
              </div>
              <div className="text-center">
                <h3 className="font-semibold">Mobile Access Disabled</h3>
                <p className="text-sm text-muted-foreground mt-1">
                  Enable mobile access to connect the Tracearr app to your server
                </p>
              </div>
              <Button onClick={() => enableMobile.mutate()} disabled={enableMobile.isPending}>
                {enableMobile.isPending ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    Enabling...
                  </>
                ) : (
                  'Enable Mobile Access'
                )}
              </Button>
            </div>
          ) : (
            <>
              <div className="flex flex-wrap gap-2">
                <Button
                  onClick={handleAddDevice}
                  disabled={generatePairToken.isPending || !canAddDevice}
                >
                  {generatePairToken.isPending ? (
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  ) : (
                    <Plus className="mr-2 h-4 w-4" />
                  )}
                  Add Device
                </Button>
                <Button
                  variant="outline"
                  onClick={() => setShowDisableConfirm(true)}
                >
                  Disable Mobile Access
                </Button>
              </div>

              {!canAddDevice && (
                <p className="text-sm text-muted-foreground">
                  Maximum of {config?.maxDevices} devices reached. Remove a device to add another.
                </p>
              )}

              {!settings?.externalUrl && (
                <div className="rounded-lg bg-muted/50 p-3">
                  <p className="text-xs text-muted-foreground">
                    Configure an External URL in{' '}
                    <a href="/settings/network" className="text-primary hover:underline">
                      Network settings
                    </a>{' '}
                    for remote access.
                  </p>
                </div>
              )}
            </>
          )}
        </CardContent>
      </Card>

      {config?.isEnabled && config.sessions.length > 0 && (
        <Card>
          <CardHeader>
            <div className="flex items-center justify-between">
              <div>
                <CardTitle>Connected Devices</CardTitle>
                <CardDescription>
                  {config.sessions.length} of {config.maxDevices} device{config.sessions.length !== 1 ? 's' : ''} connected
                </CardDescription>
              </div>
              <Button
                variant="outline"
                size="sm"
                onClick={() => setShowRevokeConfirm(true)}
              >
                <LogOut className="mr-2 h-4 w-4" />
                Revoke All
              </Button>
            </div>
          </CardHeader>
          <CardContent>
            <div className="space-y-4">
              {config.sessions.map((session) => (
                <MobileSessionCard key={session.id} session={session} />
              ))}
            </div>
          </CardContent>
        </Card>
      )}

      {/* Add Device Dialog */}
      <Dialog open={showAddDevice} onOpenChange={setShowAddDevice}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Add Mobile Device</DialogTitle>
            <DialogDescription>
              Scan this QR code with the Tracearr mobile app
            </DialogDescription>
          </DialogHeader>

          {pairToken && timeRemaining !== 'Expired' ? (
            <div className="space-y-4">
              <div className="flex flex-col items-center gap-4">
                <div className="rounded-lg border bg-white p-4">
                  <QRCodeSVG
                    value={getQRData()}
                    size={200}
                    level="M"
                    marginSize={0}
                  />
                </div>
                <div className="flex items-center gap-2 text-sm text-muted-foreground">
                  <Clock className="h-4 w-4" />
                  Expires in {timeRemaining}
                </div>
              </div>

              <div className="space-y-2">
                <Label>Or enter token manually</Label>
                <div className="flex gap-2">
                  <Input
                    readOnly
                    value={pairToken.token}
                    className="font-mono text-xs"
                  />
                  <Button
                    variant="outline"
                    size="icon"
                    onClick={handleCopyToken}
                    title="Copy token"
                  >
                    {copied ? (
                      <CheckCircle2 className="h-4 w-4 text-green-600" />
                    ) : (
                      <Copy className="h-4 w-4" />
                    )}
                  </Button>
                </div>
              </div>

              <div className="rounded-lg bg-muted/50 p-3">
                <p className="text-xs text-muted-foreground">
                  <strong>Server URL:</strong>{' '}
                  <code className="rounded bg-background px-1">{getServerUrl()}</code>
                </p>
              </div>
            </div>
          ) : (
            <div className="flex flex-col items-center gap-4 py-8">
              <p className="text-muted-foreground">Token has expired</p>
              <Button onClick={handleAddDevice} disabled={generatePairToken.isPending}>
                Generate New Token
              </Button>
            </div>
          )}

          <DialogFooter>
            <Button variant="outline" onClick={() => setShowAddDevice(false)}>
              Done
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Disable Confirmation Dialog */}
      <Dialog open={showDisableConfirm} onOpenChange={setShowDisableConfirm}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Disable Mobile Access</DialogTitle>
            <DialogDescription>
              Are you sure you want to disable mobile access? All connected devices will be
              disconnected and will need to be re-paired when you re-enable.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button variant="outline" onClick={() => setShowDisableConfirm(false)}>
              Cancel
            </Button>
            <Button
              variant="destructive"
              onClick={() => {
                disableMobile.mutate();
                setShowDisableConfirm(false);
              }}
              disabled={disableMobile.isPending}
            >
              {disableMobile.isPending ? 'Disabling...' : 'Disable'}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Revoke All Sessions Confirmation */}
      <Dialog open={showRevokeConfirm} onOpenChange={setShowRevokeConfirm}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Revoke All Sessions</DialogTitle>
            <DialogDescription>
              Are you sure you want to disconnect all mobile devices? They will need to scan a
              new QR code to reconnect.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button variant="outline" onClick={() => setShowRevokeConfirm(false)}>
              Cancel
            </Button>
            <Button
              variant="destructive"
              onClick={() => {
                revokeMobileSessions.mutate();
                setShowRevokeConfirm(false);
              }}
              disabled={revokeMobileSessions.isPending}
            >
              {revokeMobileSessions.isPending ? 'Revoking...' : 'Revoke All'}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}
```

**Step 2: Update imports at top of Settings.tsx**

Add these imports:

```typescript
import { Plus, Clock } from 'lucide-react';
import { useGeneratePairToken, useRevokeSession } from '@/hooks/queries/useMobile';
```

**Step 3: Commit**

```bash
git add apps/web/src/pages/Settings.tsx
git commit -m "feat(web): update MobileSettings UI for one-time tokens"
```

---

## Task 14: Update MobileSessionCard with Delete Button

**Files:**
- Modify: `apps/web/src/pages/Settings.tsx:1160-1184`

**Step 1: Replace MobileSessionCard**

```typescript
function MobileSessionCard({ session }: { session: MobileSession }) {
  const revokeSession = useRevokeSession();
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);

  return (
    <>
      <div className="flex items-center justify-between rounded-lg border p-4">
        <div className="flex items-center gap-4">
          <div className="flex h-10 w-10 items-center justify-center rounded-lg bg-muted">
            <Smartphone className="h-5 w-5" />
          </div>
          <div>
            <div className="flex items-center gap-2">
              <h3 className="font-semibold">{session.deviceName}</h3>
              <span className="rounded bg-muted px-2 py-0.5 text-xs capitalize">
                {session.platform}
              </span>
            </div>
            <p className="text-sm text-muted-foreground">
              Last seen {formatDistanceToNow(new Date(session.lastSeenAt), { addSuffix: true })}
            </p>
            <p className="text-xs text-muted-foreground">
              Paired {format(new Date(session.createdAt), 'MMM d, yyyy')}
            </p>
          </div>
        </div>
        <Button
          variant="ghost"
          size="icon"
          onClick={() => setShowDeleteConfirm(true)}
          title="Remove device"
        >
          <Trash2 className="h-4 w-4 text-muted-foreground hover:text-destructive" />
        </Button>
      </div>

      <Dialog open={showDeleteConfirm} onOpenChange={setShowDeleteConfirm}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Remove Device</DialogTitle>
            <DialogDescription>
              Are you sure you want to remove "{session.deviceName}"? The device will need to
              scan a new QR code to reconnect.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button variant="outline" onClick={() => setShowDeleteConfirm(false)}>
              Cancel
            </Button>
            <Button
              variant="destructive"
              onClick={() => {
                revokeSession.mutate(session.id);
                setShowDeleteConfirm(false);
              }}
              disabled={revokeSession.isPending}
            >
              {revokeSession.isPending ? 'Removing...' : 'Remove'}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  );
}
```

**Step 2: Add Trash2 import**

Add to the lucide-react import:

```typescript
import { Trash2 } from 'lucide-react';
```

**Step 3: Commit**

```bash
git add apps/web/src/pages/Settings.tsx
git commit -m "feat(web): add delete button to MobileSessionCard"
```

---

## Task 15: Fix Copy Token Button Error Handling

**Files:**
- Already done in Task 13

The copy button fix is already included in the `handleCopyToken` function in Task 13:

```typescript
const handleCopyToken = async () => {
  if (!pairToken?.token) return;

  try {
    await navigator.clipboard.writeText(pairToken.token);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  } catch (err) {
    // Clipboard API may not be available (non-HTTPS)
    console.error('Failed to copy:', err);
  }
};
```

If you want toast feedback, add:

```typescript
const { toast } = useToast();

const handleCopyToken = async () => {
  if (!pairToken?.token) return;

  try {
    await navigator.clipboard.writeText(pairToken.token);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
    toast({ title: 'Token copied to clipboard' });
  } catch (err) {
    console.error('Failed to copy:', err);
    toast({
      title: 'Failed to copy',
      description: 'Please select and copy manually',
      variant: 'destructive',
    });
  }
};
```

---

## Task 16: Add Token Cleanup Job (Optional Enhancement)

**Files:**
- Create: `apps/server/src/jobs/cleanupMobileTokens.ts`

**Step 1: Create cleanup job file**

```typescript
/**
 * Cleanup job for expired/used mobile pairing tokens
 *
 * Run via cron or BullMQ scheduler to periodically clean up:
 * - Expired unused tokens (older than 1 hour)
 * - Used tokens (older than 30 days)
 */

import { lt, and, isNull, isNotNull } from 'drizzle-orm';
import { db } from '../db/client.js';
import { mobileTokens } from '../db/schema.js';

export async function cleanupMobileTokens(): Promise<{ deleted: number }> {
  const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
  const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);

  // Delete expired unused tokens older than 1 hour
  const expiredResult = await db
    .delete(mobileTokens)
    .where(
      and(
        lt(mobileTokens.expiresAt, oneHourAgo),
        isNull(mobileTokens.usedAt)
      )
    )
    .returning({ id: mobileTokens.id });

  // Delete used tokens older than 30 days
  const usedResult = await db
    .delete(mobileTokens)
    .where(
      and(
        isNotNull(mobileTokens.usedAt),
        lt(mobileTokens.usedAt, thirtyDaysAgo)
      )
    )
    .returning({ id: mobileTokens.id });

  return { deleted: expiredResult.length + usedResult.length };
}
```

**Step 2: Register in scheduler (if using BullMQ)**

Add to your job scheduler initialization:

```typescript
import { cleanupMobileTokens } from './jobs/cleanupMobileTokens.js';

// Run every 30 minutes
scheduler.add('cleanup-mobile-tokens', { repeat: { every: 30 * 60 * 1000 } });
```

**Step 3: Commit**

```bash
git add apps/server/src/jobs/cleanupMobileTokens.ts
git commit -m "feat(jobs): add mobile token cleanup job"
```

---

## Task 17: Run Tests and Verify

**Step 1: Run backend tests**

```bash
cd apps/server && pnpm test
```

Expected: All tests pass

**Step 2: Run frontend type check**

```bash
cd apps/web && pnpm typecheck
```

Expected: No type errors

**Step 3: Run linting**

```bash
pnpm lint
```

Expected: No lint errors

**Step 4: Manual testing**

1. Enable mobile access
2. Click "Add Device" - should show QR with countdown
3. Wait for expiry - should show "Expired" message
4. Generate new token - should work
5. Add a second device (simulate with different deviceId)
6. Delete one device - should only remove that one
7. Revoke all - should clear all devices
8. Disable mobile - should clear everything

**Step 5: Final commit**

```bash
git add -A
git commit -m "test: verify mobile device management implementation"
```

---

## Summary

| Task | Description | Files |
|------|-------------|-------|
| 1 | Add `mobileEnabled` to settings | schema.ts, migration |
| 2 | Update `mobileTokens` schema | schema.ts, migration |
| 3 | Update shared types | types.ts |
| 4 | Update `GET /mobile` | mobile.ts |
| 5 | Update `POST /mobile/enable` | mobile.ts |
| 6 | Add `POST /mobile/pair-token` | mobile.ts |
| 7 | Update `POST /mobile/disable` | mobile.ts |
| 8 | Remove `POST /mobile/rotate` | mobile.ts |
| 9 | Add `DELETE /mobile/sessions/:id` | mobile.ts |
| 10 | Update `POST /mobile/pair` | mobile.ts |
| 11 | Update API client | api.ts |
| 12 | Update React Query hooks | useMobile.ts |
| 13 | Update MobileSettings UI | Settings.tsx |
| 14 | Add delete to MobileSessionCard | Settings.tsx |
| 15 | Fix copy button | Settings.tsx |
| 16 | Add cleanup job | cleanupMobileTokens.ts |
| 17 | Test and verify | - |
